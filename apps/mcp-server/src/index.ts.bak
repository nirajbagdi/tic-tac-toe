import express from 'express';
import { randomUUID } from 'crypto';
import fetch from 'node-fetch';
import { io as socketIOClient, Socket } from 'socket.io-client';

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { isInitializeRequest } from '@modelcontextprotocol/sdk/types.js';
import { GameSession } from '@repo/game-core';
import { z } from 'zod';

// Keep track of active game sessions and their sockets
const activeGames = new Map<string, { socket: Socket; session: GameSession }>();

const app = express();
app.use(express.json());

const port = process.env.PORT || 3001;
const BACKEND_URL = 'http://localhost:3000';

const server = new McpServer({
    name: 'tic-tac-toe-server',
    version: '1.0.0',
});

// Tool 1: Create a new game session and join as player X
server.registerTool(
    'createGameSession',
    {
        title: 'Create a new Tic-Tac-Toe Game Session',
        description: 'Creates a new game session and joins as player X',
    },
    async function () {
        try {
            const response = await fetch(`${BACKEND_URL}/sessions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
            });

            if (!response.ok) throw new Error('Failed to create game session');

            const jsonResponse = await response.json();
            const session = jsonResponse as GameSession;

            // Create socket connection
            const socket = socketIOClient(BACKEND_URL);
            
            // Store the socket and session
            activeGames.set(session.id, { socket, session });

            // Join the game session
            socket.emit('joinGame', session.id);

            return {
                content: [
                    {
                        type: 'text',
                        text: `Game session created. Session ID: ${session.id}. You are player X.`,
                    },
                ],
            };
        } catch (error) {
            if (error instanceof Error)
                throw new Error(`Failed to create game session: ${error.message}`);
            throw new Error('Failed to create game session: Unknown error');
        }
    }
);

// Tool 2: Wait for opponent to join
server.registerTool(
    'waitForOpponent',
    {
        title: 'Wait for Opponent',
        description: 'Waits for player O to join the game session',
        inputSchema: {
            sessionId: z.string(),
        },
    },
    async function (args) {
        const { sessionId } = args; {
        const activeGame = activeGames.get(params.sessionId);
        if (!activeGame) {
            throw new Error('Game session not found');
        }

        return new Promise((resolve, reject) => {
            const { socket, session } = activeGame;

            // Set a timeout of 60 seconds
            const timeout = setTimeout(() => {
                reject(new Error('Timeout: No opponent joined the session'));
            }, 60000);

            socket.on('gameUpdated', (updatedSession: GameSession) => {
                if (updatedSession.players.O) {
                    clearTimeout(timeout);
                    activeGame.session = updatedSession;
                    
                    resolve({
                        content: [
                            {
                                type: 'text',
                                text: 'Player O has joined the game! Game is ready to start.',
                            },
                        ],
                    });
                }
            });

            socket.on('error', (error: Error) => {
                clearTimeout(timeout);
                reject(new Error(`Socket error: ${error.message}`));
            });
        });
    }
);

// Tool 3: Make a move
server.registerTool(
    'makeMove',
    {
        title: 'Make a Move',
        description: 'Makes a move at the specified position (0-8)',
    },
    async function (params: { sessionId: string; position: number }) {
        const activeGame = activeGames.get(params.sessionId);
        if (!activeGame) {
            throw new Error('Game session not found');
        }

        const { socket, session } = activeGame;

        return new Promise((resolve, reject) => {
            if (session.result) {
                reject(new Error('Game is already finished'));
                return;
            }

            if (session.currentPlayer !== 'X') {
                reject(new Error('Not your turn'));
                return;
            }

            socket.emit('makeMove', {
                sessionId: params.sessionId,
                index: params.position,
            });

            socket.on('gameUpdated', (updatedSession: GameSession) => {
                activeGame.session = updatedSession;
                
                let message = `Move made at position ${params.position}.`;
                if (updatedSession.result) {
                    if (updatedSession.result.winner) {
                        message += ` Player ${updatedSession.result.winner} wins!`;
                    } else if (updatedSession.result.isDraw) {
                        message += ' Game ended in a draw!';
                    }
                } else {
                    message += ' Waiting for opponent\'s move...';
                }

                resolve({
                    content: [
                        {
                            type: 'text',
                            text: message,
                        },
                    ],
                });
            });

            socket.on('error', (error: string) => {
                reject(new Error(`Game error: ${error}`));
            });
        });
    }
);

// Tool 4: Get current game state
server.registerTool(
    'getCurrentState',
    {
        title: 'Get Current Game State',
        description: 'Returns the current state of the game',
    },
    async function (params: { sessionId: string }) {
        const activeGame = activeGames.get(params.sessionId);
        if (!activeGame) {
            throw new Error('Game session not found');
        }

        const { session } = activeGame;
        let boardDisplay = '';
        for (let i = 0; i < 9; i += 3) {
            const row = session.board.slice(i, i + 3).map(cell => cell || i + '').join(' | ');
            boardDisplay += row + '\n';
            if (i < 6) boardDisplay += '---------\n';
        }
        
        return {
            content: [
                {
                    type: 'text',
                    text: `Current board:\n${boardDisplay}\nCurrent player: ${session.currentPlayer}`,
                },
            ],
        };
    }
);

// Tool 5: End game session
server.registerTool(
    'endGameSession',
    {
        title: 'End Game Session',
        description: 'Cleans up and ends the game session',
    },
    async function (params: { sessionId: string }) {
        const activeGame = activeGames.get(params.sessionId);
        if (!activeGame) {
            throw new Error('Game session not found');
        }

        const { socket } = activeGame;
        socket.disconnect();
        activeGames.delete(params.sessionId);

        return {
            content: [
                {
                    type: 'text',
                    text: 'Game session ended and cleaned up.',
                },
            ],
        };
    }
);

const transports: {
    [sessionId: string]: StreamableHTTPServerTransport;
} = {};

app.post('/mcp', async (req, res) => {
    const sessionId = req.headers['mcp-session-id'] as string | undefined;
    let transport: StreamableHTTPServerTransport;

    if (sessionId && transports[sessionId]) {
        transport = transports[sessionId];
    } else if (!sessionId && isInitializeRequest(req.body)) {
        transport = new StreamableHTTPServerTransport({
            sessionIdGenerator: () => randomUUID(),
            onsessioninitialized: (sessionId) => {
                transports[sessionId] = transport;
            },
        });

        transport.onclose = () => {
            if (transport.sessionId) delete transports[transport.sessionId];
        };

        await server.connect(transport);
    } else {
        res.status(400).json({
            jsonrpc: '2.0',
            error: {
                code: -32000,
                message: 'Bad Request: No valid session ID provided',
            },
            id: null,
        });
        return;
    }

    await transport.handleRequest(req, res, req.body);
});

const handleSessionRequest = async (req: express.Request, res: express.Response) => {
    const sessionId = req.headers['mcp-session-id'] as string | undefined;
    if (!sessionId || !transports[sessionId]) {
        res.status(400).send('Invalid or missing session ID');
        return;
    }

    const transport = transports[sessionId];
    await transport.handleRequest(req, res);
};

app.get('/mcp', handleSessionRequest);
app.delete('/mcp', handleSessionRequest);

app.listen(port, () => console.log(`MCP server running on port ${port}`));
